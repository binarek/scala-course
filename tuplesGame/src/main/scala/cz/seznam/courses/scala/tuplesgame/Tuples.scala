package cz.seznam.courses.scala.tuplesgame

import scala.util.Random

/**
  * Tuples game solution
  */
object Tuples extends App {
  // Load board settings
  val (width, height, tupleLength) =
  (System.console.readLine("Width: ").toInt,
    System.console.readLine("Height: ").toInt,
    System.console.readLine("Tuple length: ").toInt)

  // Stream turn -> board until board empty
  val (turns, _) = Stream.iterate(1 -> Board.setUp()) { case (turn, board) =>
    try {
      println(s"Turn $turn:")
      // Get coordinates input and print board with revealed tiles on each
      val chosen = (0 until tupleLength).foldLeft(List.empty[(Int, Int)]) { case (chosenBefore, i) =>
        val chosen = (System.console.readLine("x = ").toInt, System.console.readLine("y = ").toInt) :: chosenBefore
        println(board.toString((x, y) => chosen.contains(x -> y)))
        chosen
      }
      // Advance turn and clear tiles if there are same numbers on each
      turn + 1 -> (
        if (chosen.map(board.map).distinct.size == 1)
          Board(board.map -- chosen)
        else board)
    } catch {
      // Catch any exceptions
      case t: Throwable =>
        println(s"Error: ${t.getMessage}")
        turn -> board
    }
  }.takeWhile(_._2.map.nonEmpty).last

  // Print number of turns
  println(s"Done in $turns turns")

  /**
    * Board representation
    *
    * @param map Map of coordinates -> numbers
    */
  case class Board(map: Map[(Int, Int), Int]) {
    /**
      * Create a string representation of the board with revealed tiles by predicate
      */
    def toString(reveal: (Int, Int) => Boolean) =
    (0 until width).map(x =>
      (0 until height).map(y =>
        map.get(x, y)
          .map(n => if (reveal(x, y)) n.toString else "x")
          .getOrElse(" "))
        .mkString(" "))
      .mkString("\n")

    /**
      * Create a string representation of the board with every tile revealed
      */
    override def toString = toString((_, _) => true)
  }

  object Board {
    /**
      * Set up the board by zipping all tiles with shuffled numbers.
      * Numbers are generated by getting maximum tile count on board, dividing by tupleLength
      * and duplicating by tupleLength
      */
    def setUp(): Board =
    Board((for {
      x <- 0 until width
      y <- 0 until height
    } yield (x, y))
      .zip(
        Seq.range(0, width * height / tupleLength)
          .flatMap(i => Seq.fill(tupleLength)(i))
          .shuffle)
      .toMap)
  }

  implicit class Shuffler[T](val seq: Seq[T]) extends AnyVal {
    /**
      * Shuffle helper function for better readability
      */
    def shuffle = Random.shuffle(seq)
  }

}
